<?php

/**
 * @file
 * Contains HTTP response headers.
 */


/**
 * Sets this header on every page except the listed pages.
 */
define('HTTP_RESPONSE_HEADERS_VISIBILITY_NOTLISTED', 0);

/**
 * Sets this header on only the listed pages.
 */
define('HTTP_RESPONSE_HEADERS_VISIBILITY_LISTED', 1);


/**
 * Implements hook_init().
 */
function http_response_headers_init() {
  $rules = http_response_headers_get_rules();
  $callbacks = http_response_headers_get_header_callbacks();
  foreach ($rules as $rule) {
    $header_value = $rule->header_value;

    // @TODO: Find a way to callback on creating or editing of rule.
    // Process data with callback, if exist.
    if (isset($callbacks[$rule->header]) && $callback = $callbacks[$rule->header]) {
      if (function_exists($callback)) {
        $header_value = call_user_func_array($callback, array($rule->header_value));
      }
    }

    drupal_add_http_header($rule->header, $header_value);
  }
}

/**
 * Creates new object.
 *
 * Chaos tools export create callback for the http_response_headers table.
 *
 * @param bool $set_defaults
 *   A boolean passed in from Chaos tools, TRUE by default.
 *
 * @return Object
 *   A HttpResponseHeaders object.
 */
function http_response_headers_rule_create($set_defaults = TRUE) {
  $rule = new HttpResponseHeadersRule();
  if ($set_defaults) {
    $rule->description = '';
    $rule->header = '';
    $rule->header_value = '';
    $rule->pages = '';
    $rule->visibility = HTTP_RESPONSE_HEADERS_VISIBILITY_NOTLISTED;
    $rule->roles = '';
    $rule->types = '';
  }

  return $rule;
}

/**
 * Loads a HTTP header rule  object from the database.
 *
 * @param string $machine_name
 *   ID of the rule to load.
 * @param bool $reset
 *   Flag to reset cached objects.
 *
 * @return stdClass
 *   A header rule object.
 */
function http_response_headers_rule_load($machine_name, $reset = FALSE) {
  // Use CTools export API to fetch this header rule.
  ctools_include('export');

  // Reset the static cache if required.
  if ($reset) {
    ctools_export_load_object_reset('http_response_headers');
  }

  $result = ctools_export_load_object('http_response_headers', 'names', array($machine_name));

  if (isset($result[$machine_name])) {
    return $result[$machine_name];
  }
}

/**
 * Load all header rules.
 *
 * @return array
 *   An array of HttpResponseHeadersRule objects, keyed by the machine name of
 *   each pool.
 */
function http_response_headers_rule_load_all() {
  // Use CTools export API to fetch this header rule.
  ctools_include('export');
  $result = ctools_export_load_object('http_response_headers', 'all');

  return $result;
}

/**
 * Save a single header rule to the database.
 *
 * @param HttpResponseHeadersRule $rule
 *   The rule object.
 *
 * @return bool
 *   TRUE or FALSE flag of save operation.
 */
function http_response_headers_rule_save(HttpResponseHeadersRule $rule) {
  db_merge('http_response_headers')
    ->key(array('machine_name' => $rule->machine_name))
    ->fields(array(
      'description' => $rule->description,
      'header' => $rule->header,
      'header_value' => $rule->header_value,
      'pages' => $rule->pages,
      'visibility' => $rule->visibility,
      'types' => $rule->types,
      'roles' => $rule->roles,
      // Serialize the whole object into data column, this way, any classes that
      // subclass the base object will have an opportunity to save their data
      // too!
      'data' => serialize($rule),

    ))
    ->execute();

  return TRUE;
}

/**
 * Export a single message queue pool from the DB.
 */
function http_response_headers_rule_export($object, $indent = '') {
  $output = $indent . '$header_rule = new ' . get_class($object) . '()' . ";\n";
  $output .= $indent . '$header_rule->disabled = FALSE; /* Edit this to true to make a default pool disabled initially */' . "\n";
  $output .= $indent . '$header_rule->api_version = 1' . ";\n";
  $output .= $indent . '$header_rule->machine_name = "' . $object->machine_name . "\";\n";
  $output .= $indent . '$header_rule->description = "' . $object->description . "\";\n";
  $output .= $indent . '$header_rule->header = "' . $object->header . "\";\n";
  $output .= $indent . '$header_rule->header_value = "' . $object->header_value . "\";\n";
  $output .= $indent . '$header_rule->visibility =  "' . $object->visibility . "\";\n";
  $output .= $indent . '$header_rule->pages = "' . $object->pages . "\";\n";
  $output .= $indent . '$header_rule->types = "' . $object->types . "\";\n";
  $output .= $indent . '$header_rule->roles =  "' . $object->roles   . "\";\n";

  return $output;
}

/**
 * Factory for rule objects.
 *
 * Chaos tools export object factory callback for the
 * http_response_headers table.
 *
 * @param string $schema
 *   An array, a Drupal table schema definition as returned by
 *   drupal_get_schema().
 * @param object $data
 *   An object, a row from the http_response_headers table.
 *
 * @return HttpResponseHeadersRule
 *   A HttpResponseHeadersRule object.
 */
function http_response_headers_rule_factory($schema, $data) {
  $rule = unserialize($data->data);
  $rule->machine_name = $data->machine_name;
  $rule->description  = $data->description;
  $rule->header  = $data->header;
  $rule->header_value  = $data->header_value;
  $rule->pages  = $data->pages;
  $rule->visibility  = $data->visibility;
  $rule->types  = $data->types;
  $rule->roles  = $data->roles;

  return $rule;
}

/**
 * Provides applicable rules for current page.
 *
 * @return mixed
 *   An array of matching header rules indexed with rule ID, NULL otherwise.
 */
function http_response_headers_get_rules() {
  global $user;

  $result = db_select('http_response_headers')
    ->fields('http_response_headers')
    ->execute();

  $rules = $result->fetchAllAssoc('machine_name');

  foreach ($rules as $key => $rule) {

    // If a rule has no roles associated, it is displayed for every role.
    // For rules with roles associated, if none of the user's roles matches
    // the settings from this rule, remove it from the rule list.
    if (!empty($rule->roles) && !array_intersect(explode(',', $rule->roles), array_keys($user->roles))) {
      // No match.
      unset($rules[$key]);
      continue;
    }

    $enabled = TRUE;
    // Limited visibility rules must list at least one page.
    if ($rule->visibility == HTTP_RESPONSE_HEADERS_VISIBILITY_LISTED && empty($rule->pages)) {
      $enabled = FALSE;
    }

    if (!$enabled) {
      unset($rules[$key]);
      continue;
    }

    // Match path if necessary.
    if ($rule->pages) {
      // Convert path to lowercase. This allows comparison of the same path
      // with different case. Ex: /Page, /page, /PAGE.
      $pages = drupal_strtolower($rule->pages);
      if ($rule->visibility <= HTTP_RESPONSE_HEADERS_VISIBILITY_LISTED) {
        // Convert the Drupal path to lowercase.
        $path = drupal_strtolower(drupal_get_path_alias($_GET['q']));
        // Compare the lowercase internal and lowercase path alias (if any).
        $page_match = drupal_match_path($path, $pages);
        if ($path != $_GET['q']) {
          $page_match = $page_match || drupal_match_path($_GET['q'], $pages);
        }
        // When $rule->visibility has a value of 0
        // (HTTP_RESPONSE_HEADERS_VISIBILITY_NOTLISTED),the header is set on
        // all pages except those listed in $rule->pages.
        // When set to 1 (HTTP_RESPONSE_HEADERS_VISIBILITY_LISTED), it is set
        // only on those pages listed in $rule->pages.
        $page_match = !($rule->visibility xor $page_match);
      }
      else {
        $page_match = FALSE;
      }
    }
    else {
      $page_match = TRUE;
    }
    if (!$page_match) {
      unset($rules[$key]);
    }

    // Match content types.
    $node = menu_get_object();
    $node_types = node_type_get_types();
    if (arg(0) == 'node' && arg(1) == 'add' && arg(2)) {
      $node_add_arg = strtr(arg(2), '-', '_');
    }
    // If a rule has no node types associated, it is displayed for every type.
    // For rules with node types associated, if the node type does not match
    // the settings from this rule, remove it from the list.
    if (!empty($rule->types)) {
      $rule_node_types = explode(',', $rule->types);
      if (!empty($node)) {
        // This is a node or node edit page.
        if (!in_array($node->type, $rule_node_types)) {
          // This rule should not be set for this node type.
          unset($rules[$key]);
          continue;
        }
      }
      elseif (isset($node_add_arg) && isset($node_types[$node_add_arg])) {
        // This is a node creation page.
        if (!in_array($node_add_arg, $rule_node_types)) {
          // This header should not be set for this node type.
          unset($rules[$key]);
          continue;
        }
      }
      else {
        // This is not a node page, remove the rule.
        unset($rules[$key]);
        continue;
      }
    }
  }

  return $rules;
}

/**
 * Callback to delete a header rule.
 *
 * @param string $machine_name
 *   A string rule ID to delete.
 */
function http_response_headers_rule_delete($machine_name) {
  db_delete('http_response_headers')
    ->condition('machine_name', $machine_name)
    ->execute();

  // Clear the header rules cache.
  http_response_headers_cache_reset();

}

/**
 * Updates the database cache of header rules.
 *
 * @see _http_response_headers_rebuild()
 */
function http_response_headers_rebuild() {
  _http_response_headers_rebuild(TRUE);
}


/**
 * Builds and returns the list of available HTTP header rules.
 *
 * The list of rules is built by header rules in the {http_response_headers}
 * table.
 *
 * @param bool $rebuild
 *   TRUE to rebuild node types. Equivalent to calling
 *   http_response_headers_rebuild().
 *
 * @return DatabaseStatementInterface|null
 *   An object
 */
function _http_response_headers_rebuild($rebuild = FALSE) {
  $cid = 'http_response_headers';

  if (!$rebuild) {
    $_header_rules = &drupal_static(__FUNCTION__);
    if (isset($_header_rules)) {
      return $_header_rules;
    }
    if ($cache = cache_get($cid)) {
      $_header_rules = $cache->data;
      return $_header_rules;
    }
  }

  $_header_rules = db_select('http_response_headers', 'h')
    ->fields('h')
    ->execute()
    ->fetchAllAssoc('machine_name');
  cache_set($cid, $_header_rules);

  return $_header_rules;
}

/**
 * Clears the header rule cache.
 */
function http_response_headers_cache_reset() {
  cache_clear_all('http_response_headers:', 'cache', TRUE);
  drupal_static_reset('_http_response_headers_rebuild');
}

/**
 * Provides process callback for headers.
 *
 * @return array
 *   An array of process callbacks with keyed with header.
 */
function http_response_headers_get_header_callbacks() {
  return array(
    'Expires' => 'http_response_headers_expires_callback',
    'Last-Modified' => 'http_response_headers_last_modified_callback',
  );
}

/**
 * Process callback for expires header.
 *
 * @param int $seconds
 *   Number of seconds to expire header.
 *
 * @return string
 *   String of formatted date time.
 */
function http_response_headers_expires_callback($seconds = 0) {
  return gmdate(DATE_RFC1123, strtotime("+ $seconds seconds"));
}

/**
 * Process callback for last modified header.
 *
 * @param int $seconds
 *   Number of seconds to modified header.
 *
 * @return string
 *   String of formatted date time.
 */
function http_response_headers_last_modified_callback($seconds = 0) {
  return gmdate(DATE_RFC1123, strtotime("+ $seconds seconds"));
}
